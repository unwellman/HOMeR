from functools import wraps
import os
import time

class Log:
    '''
    Data structure for interacting with screenlog.0 generated by screen
    '''
    def __init__ (self, fp):
        self.log = fp

    def filemethod (method):
        '''
        Safely run a method that accesses log file and closes log file
        Requires that file be the first argument after self
        '''
        @wraps(method)
        def run (self, *args, **kwargs):
            with open(self.log, 'rb') as file:
                return method(self, file, *args, **kwargs)
        return run

    @filemethod
    def console_output (self, log, console):
        '''
        Searches for a console command and tries to return its output
        '''
        search = console
        search = search.encode(encoding='utf-8')
        if '\n'.encode(encoding='utf-8') in search:
            raise ValueError('Multiline commands not supported')
        log.seek(0, 2) # Jump to EOF
        i = log.tell()
        step = len(search) - 1
        # Decrement step to guarantee that the cursor lands inside pattern
        log.seek(i - step)
        buf = log.read(step)
        i = log.tell()
        while search not in buf:
            if i < 2*step:
                raise IndexError('Could not find search pattern in file')
            log.seek(i - 2*step) #Jump before last read section
            buf = log.read(step) + buf #Prepend to buffer
            i = log.tell() #Prepare to jump again
        # At this point, the cursor is inside the search pattern
        line = log.readline() # Throw away the line with the command
        ret = ''.encode(encoding='utf-8')
        while line.startswith('['.encode(encoding='utf-8')):
            line = log.readline()
            ret += line
        return ret.decode(encoding='utf-8')

    def __time (self, line):
        '''
        Take one line of console output and return the time as a float
        '''
        import re
        pat = '\\[[0-9]{2}:[0-9]{2}:[0-9]{2}\\]'.encode(encoding='utf-8')
        try:
            t = re.search(pat, line).decode(encoding='utf-8')
            print(t)
            return time.strptime(t, '[%H:%M:%S]').time()
        except:
            return float('inf')

    @filemethod
    def time_listen (self, log, mins):
        '''
        Retrieve server logs back the specified number of minutes
        '''
        from collections import deque
        BUF_SIZE = 512
        NEWLINE = '\n'.encode(encoding='utf-8')
        ref_time = time.time() - 60*mins
        log.seek(0, 2)
        i = log.tell()
        log.seek(i - BUF_SIZE)
        ret = deque()
        lines = []
        done = False
        while not done:
            try:
                buf = log.read(BUF_SIZE) + lines[0]
            except IndexError:
                buf = log.read(BUF_SIZE)
            i = log.tell()
            lines = buf.split(NEWLINE)
            for line in lines[1::-1]:
                t = self.__time(line)
                print(f'Comparing {t} < {ref_time}')
                if self.__time(line) < ref_time:
                    done = True
                    break
                ret.appendleft(line.decode(encoding='utf-8'))
            if i < 2*BUF_SIZE:
                break
            step = min(i, 2*BUF_SIZE)
            log.seek(i - step)
        return '\n'.join(ret)



